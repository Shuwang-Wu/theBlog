<!--
 * @Author: shuwang_wu
 * @Date: 2021-05-07 10:31:26
 * @LastEditTime: 2021-09-16 15:27:13
 * @LastEditors: shuwang_wu
 * @Description:
 * @FilePath: \notes\notes\notes\stack-heap.md
-->

# 堆栈的区别

## 定义

- 栈区(stack)
  - 由编译器自动分配释放,存放函数的参数值,局部变量的值等.其操作方式类似于数据结构中的栈
  - 有操作系统自动释放,存放函数的参数值, 局部变量的值等.其操作方式类似于数据结构中的栈
- 堆区(heap)
  - 一般由程序员分配释放,若程序员不释放,程序结束时可能由 OS 回收
  - 一般有程序员分配释放,若程序员不释放,程序结束时可能由 OS 回收,分配方式类似于链表

## 例子

```c
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。
    static int c =0； //全局（静态）初始化区
    p1 = (char *)malloc(10); //堆
    p2 = (char *)malloc(20);  //堆
}
```

## 区别

- 申请方式和回收方式

  - 申请方式不同：栈（英文名称是 stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。而堆（英文名称是 heap）则是程序员根据需要自己申请的空间，例如 malloc（10）；开辟十个字节的空间。
  - 栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露

- 申请之后的系统响应

  - 栈 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出
  - 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

- 申请效率的比较

  - 栈：由系统自动分配，速度较快。但程序员是无法控制的。
  - 堆：是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片不过用起来最方便。

- 申请大小的限制

  - 栈：在 Windows 下栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
  - 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

- 堆和栈中的存储内容

  > ## 由于栈的大小有限，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。

## 值传递和引用传递

> 对于是按值传递、按引用传递还是按共享传递, 在计算机科学里面, 这个部分叫求职策略
> js 中都是按值传递(按引用传递是传递对象的引用, 而按共享传递是传递对象的引用的副本,也是属于按值传递)

### 值传递( call by value )

- 函数的形参是被调用时所传实参的副本, 修改形参的值并不会影响实参
- 例子

```js
function add(num) {
  num += 10
  return num
}
num = 10
console.log(add(10))
console.log(num)
// 输出20,10
// JS的官方解释就是在基本类型参数传递的时候，做了一件复制栈帧的拷贝动作，这样外部声明的变量num和函数参数的num，拥有完全相同的值，但拥有完全不同的参数地址，两者谁都不认识谁，在函数调用返回的时候弹出函数参数num栈帧。所以改变函数参数num，对原有的外部变量没有一点影响

function setName(obj) {
  obj.name = 'ted'
}
var obj = new Object()
setName(obj)
console.log(obj) // {name: 'ted'}
// 这里严格的说，在和JAVA类似的语言中，已经没有了指针，在JAVA里将上述过程称之为一个从符号引用到直接引用的解析过程
```

### 引用传递( call by reference )

- 函数的形参被调用时所传参数是实参在内存中的一个指针
